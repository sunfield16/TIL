UniRxは有志により制作されたUnity向けライブラリ。  
もともとはMicrosoftResearchが開発していた非同期処理向けのライブラリの  
`ReactiveExtensions`があり、それをUnity向けとして作成したものとされている。

## 特徴
* Observerパターンがベースになっている
* 特に、時間に関係した処理・実行タイミングに関わる処理を簡単に記述できる
* C#における`event`の完全上位互換

## 基本の概念
主に使うのはSubject, IObservable, IObserver。

### Subject
* イベント機構の中核になるもの。購読対象を定義する
  - 例えば、タイマーのカウントやキャラクターのHPなどを購読対象としたSubjectを定義する
  - IObservable, IObserverの両方を実装している

### IObservable
* イベントを受け取れる（購読できる）ことを表すインターフェース
  - これを外部に公開して、他のクラスに購読してもらう
* イベントを受け取るための`Subscribe`メソッドを持っている
  - これにIObserverやラムダ式を登録することで、受け取った通知を処理できる

### IObserver
* イベントを発行できる（購読対象を観測・通知できる）ことを表すインターフェース
  - こっちは基本的に外部に見せない
* イベントを発行するための`OnNext`メソッドを持っている
  - これが呼ばれる＝「購読対象に何かイベントが発生した時」となる

### 基本の使い方
1. イベント発行側（使われる側）でSubjectを作成し、IObservableをプロパティとして公開
2. イベントを購読したい側（使う側）で、IObservableのSubscribeを使って処理を登録
3. イベントを発行したいタイミングで、SubjectのOnNextを実行
4. 受け取ったイベントをもとにSubscribeで登録した処理たちが実行される

## UniRx vs `async/await`
### UniRxの使いどころ
* イベント処理機構（何らかの条件をトリガーに、他のオブジェクトにメッセージを発行）
  - 不特定多数に複数回送るような場面では特に有効
  - UniRxで用意されたオペレータの範囲であれば、複雑なものもある程度対応できる
* UI関連の実装
  - クリックなどのインタラクトを受けたりHPなどを参照してリアルタイムに反映するUIとは相性がよい

### `async/await`の使いどころ
* 初期化処理を待ったり、外部との通信を待つ
  - 1回だけ実行される処理を待つような場合に有効
* 手続き的な処理（if文やfor文など）で書く必要がある場合
  - UniRxは手続き的な処理が苦手
* 条件分岐をはじめとした、ロジックが複雑な処理
  - UniRxのオペレータの組み合わせだけでは難しいものもある
    - オペレータで解決できなさそうなら、`async/await`にした方が簡潔に済むことも多い

## 参考
<https://qiita.com/toRisouP/items/2f1643e344c741dd94f8>  
<https://qiita.com/toRisouP/items/af7d32846ab99f493d92>  
（ちょっと古くなってしまった記事もあるが、基礎の概念とかはあまり変わってないはず）